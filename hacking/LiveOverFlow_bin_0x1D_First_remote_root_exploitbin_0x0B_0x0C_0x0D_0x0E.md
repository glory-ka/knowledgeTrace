**NOTE : ONLY THE INSTRUCTION POINTER (EIP) RUNS CODE OR PASS BYTES TO THE CPU**


### __SETUID__

```text
_ rwx rwx rwx : File_type. Owner. Group. World

- rws ___ ___ : The 's' means that the program runs with the permission of its owner.
	      : If owner is Root, this create a potential for exploit to gain root access.
```

#### __gdb__

```text
(gdb) info proc mappings	: show the mapping of the memory.
(gdb) del			: delete all breakpoints.

(gdb) define hook-stop		: The hook enable command to run at every checkpoint stop.
>info register			: print the register check point.
>x/24wx $esp			: print [24 words] from the stack starting at 'esp'.
>x/2i 	$eip			: print the next [2 instruction] at check point.
>end				: exit the hook-stop mode.

(gdb) r				: short for 'run'
(gdb) c				: continue execute or restart form the beginning. Press ENTER, pass value to the program, if needed.
(gdb) x/wx $esp+0x5c		: show value at $address.
```
#### __gdb__
```text
(gdb) x function_name		: Examime function by printing its address.
(gdb) p function_name		: Print the function address.
(gdb) stepi or si             	: Execute one machine instruction (follows a call)
(gdb) x/s $address		: Return a STRING, starting at $address to END OF STRING.

x /CT A                 Examining memory where:
                        C   number of units to display. 
                        T   x hex integer.
                            d dec integer.
                            u unsigned dec integer.
                            o octal integer.
                            c character.
			    w word.
                            s null terminated string.
                            i as machine instruction.
                        A   an absolute address or 
                            $reg pointed by some register

```
### __Objdump__

```bash
# prints out all symbols, tycally the output is pipe to 'grep' to search for specific items.
objdump -t file_ELF
```

### __Python__
```python
import struct

eip = struct.pack("I", 0xEFFEFFEF)	: convert Integer into binary string.
````

### __ENV__
```bash
# Environment variable
env 

# Remove all environment variable
shell$ env -i ./my_program 

# Remove all environment variable
(gdb) unser env
```
Removing Environment variable before executing a binary to control the size of the stack, hence its addresses.

A better option to avoid this type of problem is to use the NO-OP instruction: **\x90**

	
### __FINAL NOTE__

```bash
# We use exploit to inject hex instruction and address to stack5 to open a shell.
# The shell was not working as intended because its input was exploit.py output.
# To solve the problem, we use cat to create a permanent input pipe.

(python exploit.py; cat) | directory/stack5
```
	
[Shell OPCODES Source](http://shell-storm.org/shellcode/files/shellcode-811.php)



